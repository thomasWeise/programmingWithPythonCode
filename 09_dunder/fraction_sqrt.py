"""A square root algorithm based on fractions."""

from fraction import ONE, ONE_HALF, ZERO, Fraction


def sqrt(number: Fraction, max_steps: int = 10) -> Fraction:
    """
    Compute the square root of a given :class:`Fraction`.

    :param number: The rational number to compute the square root of.
    :param max_steps: the maximum number of steps, defaults to `10`
    :return: A value `v` such that `v * v` is approximately `number`.

    >>> sqrt(Fraction(2, 1)).decimal_str(750)
    '1.4142135623730950488016887242096980785696718753769480731766797379\
90732478462107038850387534327641572735013846230912297024924836055850737\
21264412149709993583141322266592750559275579995050115278206057147010955\
99716059702745345968620147285174186408891986095523292304843087143214508\
39762603627995251407989687253396546331808829640620615258352395054745750\
28775996172983557522033753185701135437460340849884716038689997069900481\
50305440277903164542478230684929369186215805784631115966687130130156185\
68987237235288509264861249497715421833420428568606014682472077143585487\
41556570696776537202264854470158588016207584749226572260020855844665214\
58398893944370926591800311388246468157082630100594858704003186480342194\
89727829064104507263688131373985525611732204025'
    >>> sqrt(Fraction(4, 1)).decimal_str()
    '2'
    >>> (ONE_HALF * (ONE + sqrt(Fraction(5, 1)))).decimal_str(420)
    '1.6180339887498948482045868343656381177203091798057628621354486227\
05260462818902449707207204189391137484754088075386891752126633862223536\
93179318006076672635443338908659593958290563832266131992829026788067520\
87668925017116962070322210432162695486262963136144381497587012203408058\
87954454749246185695364864449241044320771344947049565846788509874339442\
21254487706647809158846074998871240076521705751797883416625624940758907'
    """
    if number < ZERO:  # No negative numbers are permitted.
        raise ValueError(f"Cannot computed sqrt({number}).")
    guess: Fraction = ONE       # This will hold the current guess.
    old_guess: Fraction = ZERO  # 0.0 is just a dummy value != guess.
    while old_guess != guess:  # Repeat until nothing changes anymore.
        old_guess = guess  # The current guess becomes the old guess.
        guess = ONE_HALF * (guess + number / guess)  # The new guess.
        max_steps -= 1      # Reduce the number of remaining steps.
        if max_steps <= 0:  # If we have exhausted the maximum steps...
            break           # ...then we stop (and return the guess).
    return guess  # Return the final guess.
